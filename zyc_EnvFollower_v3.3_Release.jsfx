desc:zyc_EnvFollower (Envelope Follower)
//author: EthanZhu @yichengzhu316@outlook.com
//version: v3.3
//changelog:
//v3.3 - Set RMS Smooth default to 15% for optimal balance
//v3.2 - Added RMS Smooth control to eliminate step-like changes
//v3.1 - Fixed Y-coordinate alignment for oscilloscope display
//v3.0 - Optimized Peak response and smooth drawing
//v2.9 - Implemented time-based smoothing for display values
//v2.8 - Fixed RMS detection mode
//v2.7 - Added time-based smoothing
//v2.6 - Implemented window-based RMS calculation
//v2.5 - Fixed RMS buffer allocation
//v2.4 - Implemented sliding window RMS
//v2.3 - Fixed RMS debug display
//v2.2 - Removed delay functionality
//v2.0 - Bug fixes and simplified
//v1.0 - Initial release

// Main Output control
slider1:0<0,100,0.01>Main Output

// Filter controls
slider2:0<-30,30,0.1>Input Gain (dB)
slider3:0<0,1,0.001>High Pass Filter (Hz)
slider4:1<0,1,0.001>Low Pass Filter (Hz)
slider5:0<0,1,1{Off,On}>Audition

// Volume Detection
slider6:0<0,1,1{Peak,RMS}>Detection Mode
slider7:10<1,1000,1>RMS Window (ms)
slider8:0<-48,0,0.1>Input Signal (dB) [Debug]
slider9:0<-48,0,0.1>Peak (dB) [Debug]
slider10:0<-48,0,0.1>RMS (dB) [Debug]
slider11:0<-48,0,0.1>Detected (dB) [Debug]

// Envelope Processing
slider21:0<0,1,0.001>Attack (s) [Exp]
slider22:0<0,1,0.001>Release (s) [Exp]
slider23:15<0,100,0.01>RMS Smooth (%)
slider24:0<-48,0,0.1>Envelope (dB) [Debug]

@init
// Basic variable initialization
mouse_last = 0;

// Filter state variables for 24dB/oct cascaded biquads
hpf1_x1 = 0; hpf1_x2 = 0; hpf1_y1 = 0; hpf1_y2 = 0;
hpf2_x1 = 0; hpf2_x2 = 0; hpf2_y1 = 0; hpf2_y2 = 0;
lpf1_x1 = 0; lpf1_x2 = 0; lpf1_y1 = 0; lpf1_y2 = 0;
lpf2_x1 = 0; lpf2_x2 = 0; lpf2_y1 = 0; lpf2_y2 = 0;

// Frequency range (Hz)
min_freq = 20;
max_freq = 20000;

// Volume detection variables
rms_win_len = 0;
rms_win_pos = 0;
rms_sum = 0;
rms_val = 0;
peak_val = 0;

// Display smoothing variables
LOUD_METER_SPEED = 0.075;  // 75ms time constant for smoothing
last_t = 0;
th_rms = 0;  // Smoothed RMS display value
th_peak = 0; // Smoothed Peak display value
peak_hold_time = 0.005; // 5ms hold time
peak_decay = exp(-1.0 / (peak_hold_time * srate)); // Calculate decay coefficient based on sample rate
detected_val = 0; // Combined detection value
env_val = 0;      // Initialize envelope value

// RMS Smooth variables
rms_smooth_value = 0;  // Smoothed RMS value for envelope processing
rms_smooth_factor = 0.1;  // Smoothing factor

// Constants
AMP_dB = 8.6562; // 20/log(10)
DB_AMP = 0.11512925464970228420089957273422; // log(10)/20

// Initialize RMS window
rms_win_len = floor(10 * 0.001 * srate); // Start with 10ms window at project sample rate
rms_win_pos = 0;
rms_sum = 0;

// Oscilloscope buffer initialization
osc_buffer_seconds = 2.0;  // 2 second display window
osc_buffer_size = floor(srate * osc_buffer_seconds);
osc_buffer_size = max(1, osc_buffer_size);

osc_buffer_ptr = 0;
_osc_init_i = 0;
while (_osc_init_i < osc_buffer_size) (
    osc_buffer[_osc_init_i] = 0.0;
    _osc_init_i += 1;
);

// UI constants
update_interval = 0.016;  // ~60fps update rate

// Envelope processing variables
env_attack = 1;   // Initialize with instant response
env_release = 1;  // Initialize with instant response

// Gain variables
gain_linear = 1;

@slider
// Always show main controls
slider_show(1, 1); // Main Output
slider_show(2, 1); // Input Gain
slider_show(3, 1); // HPF
slider_show(4, 1); // LPF
slider_show(5, 1); // Audition
slider_show(6, 1); // Detection Mode
slider_show(7, 1); // RMS Window
slider_show(8, 1); // Input Signal Debug
slider_show(9, 1); // Peak Debug
slider_show(10, 1); // RMS Debug
slider_show(11, 1); // Detected Debug
slider_show(21, 1); // Attack
slider_show(22, 1); // Release
slider_show(23, 1); // RMS Smooth
slider_show(24, 1); // Envelope Debug

// Gain - convert dB to linear
gain_linear = exp(slider2 * DB_AMP);

// Convert slider values to actual frequencies (logarithmic scale)
hpf_freq = min_freq * exp(slider3 * log(max_freq/min_freq));
lpf_freq = min_freq * exp(slider4 * log(max_freq/min_freq));

// High-pass filter coefficients (24dB/oct cascaded biquads)
hpf_w0 = 2 * $pi * hpf_freq / srate;
hpf_alpha = sin(hpf_w0) / (2 * 0.707);
hpf_a0 = 1 + hpf_alpha;
hpf_a1 = -2 * cos(hpf_w0);
hpf_a2 = 1 - hpf_alpha;
hpf_b0 = (1 + cos(hpf_w0)) / 2 / hpf_a0;
hpf_b1 = -(1 + cos(hpf_w0)) / hpf_a0;
hpf_b2 = (1 + cos(hpf_w0)) / 2 / hpf_a0;
hpf_a1 /= hpf_a0;
hpf_a2 /= hpf_a0;

// Low-pass filter coefficients (24dB/oct cascaded biquads)
lpf_w0 = 2 * $pi * lpf_freq / srate;
lpf_alpha = sin(lpf_w0) / (2 * 0.707);
lpf_a0 = 1 + lpf_alpha;
lpf_a1 = -2 * cos(lpf_w0);
lpf_a2 = 1 - lpf_alpha;
lpf_b0 = (1 - cos(lpf_w0)) / 2 / lpf_a0;
lpf_b1 = (1 - cos(lpf_w0)) / lpf_a0;
lpf_b2 = (1 - cos(lpf_w0)) / 2 / lpf_a0;
lpf_a1 /= lpf_a0;
lpf_a2 /= lpf_a0;

// Update RMS window size
new_win_len = floor(slider7 * 0.001 * srate); // Convert ms to samples at project sample rate
new_win_len = max(1, new_win_len);

// Only reset if window size actually changed
new_win_len != rms_win_len ? (
    rms_win_len = new_win_len;
    rms_win_pos = 0;  // Reset position when window size changes
    rms_sum = 0;      // Reset sum
);

// Convert exponential sliders to actual values
attack_time = slider21 == 0 ? 0 : 0.00001 * exp(slider21 * log(500000)); // 0.01ms-5s
release_time = slider22 == 0 ? 0 : 0.00001 * exp(slider22 * log(500000)); // 0.01ms-5s

// RMS Smooth parameter
rms_smooth_param = exp(slider23/100 * 1.5) - 1;  // Convert 0-100% to exponential range

// Calculate envelope coefficients using exponential decay
env_attack = attack_time == 0 ? 1 : exp(-1.0 / (attack_time * srate));
env_release = release_time == 0 ? 0 : exp(-1.0 / (release_time * srate));

// Update peak decay coefficient when sample rate changes
peak_decay = exp(-1.0 / (peak_hold_time * srate));

@sample
// Time-based smoothing for display values
t = time_precise();
speed = last_t ? 1.0-pow(0.5, (t-last_t)/LOUD_METER_SPEED) : 1;
last_t = t;

// Get input signal
in0 = spl0;
in1 = spl1;

// Apply gain to input for filtering
gain_in0 = in0 * gain_linear;
gain_in1 = in1 * gain_linear;

// High-pass filter - 24dB/oct (two second-order cascaded)
// First high-pass filter
hpf1_y0 = hpf_b0 * gain_in0 + hpf_b1 * hpf1_x1 + hpf_b2 * hpf1_x2 - hpf_a1 * hpf1_y1 - hpf_a2 * hpf1_y2;
hpf1_x2 = hpf1_x1;
hpf1_x1 = gain_in0;
hpf1_y2 = hpf1_y1;
hpf1_y1 = hpf1_y0;

// Second high-pass filter
hpf2_y0 = hpf_b0 * hpf1_y0 + hpf_b1 * hpf2_x1 + hpf_b2 * hpf2_x2 - hpf_a1 * hpf2_y1 - hpf_a2 * hpf2_y2;
hpf2_x2 = hpf2_x1;
hpf2_x1 = hpf1_y0;
hpf2_y2 = hpf2_y1;
hpf2_y1 = hpf2_y0;

// Low-pass filter - 24dB/oct (two second-order cascaded)
// First low-pass filter
lpf1_y0 = lpf_b0 * hpf2_y0 + lpf_b1 * lpf1_x1 + lpf_b2 * lpf1_x2 - lpf_a1 * lpf1_y1 - lpf_a2 * lpf1_y2;
lpf1_x2 = lpf1_x1;
lpf1_x1 = hpf2_y0;
lpf1_y2 = lpf1_y1;
lpf1_y1 = lpf1_y0;

// Second low-pass filter
lpf2_y0 = lpf_b0 * lpf1_y0 + lpf_b1 * lpf2_x1 + lpf_b2 * lpf2_x2 - lpf_a1 * lpf2_y1 - lpf_a2 * lpf2_y2;
lpf2_x2 = lpf2_x1;
lpf2_x1 = lpf1_y0;
lpf2_y2 = lpf2_y1;
lpf2_y1 = lpf2_y0;

// Store filtered signal for envelope following
filtered_signal = lpf2_y0;

// Volume detection
abs_signal = abs(filtered_signal);

// Peak detection
abs_signal > peak_val ? (
    peak_val = abs_signal;
) : (
    peak_val *= peak_decay;
);

// RMS calculation using window-based approach
rms_sum += abs_signal * abs_signal;  // Accumulate squared samples
rms_win_pos += 1;

// Calculate RMS when window is complete
rms_win_pos >= rms_win_len ? (
    rms_val = sqrt(max(0.0000001, rms_sum / rms_win_len));  // Calculate RMS
    rms_sum = 0;      // Reset accumulator
    rms_win_pos = 0;  // Reset window position
) : (
    rms_val = rms_val;  // Keep previous value during window
);

// Smooth display values
th_rms += (rms_val - th_rms) * speed;
th_peak += (peak_val - th_peak) * speed;

// RMS Smooth processing
rms_smooth_target = rms_val;
rms_smooth_param < 0.001 ? (
    rms_smooth_value = rms_smooth_target;  // No smoothing
) : (
    rms_smooth_factor = 1 - exp(-1 / (srate * rms_smooth_param * 0.1 + 0.000000001));
    rms_smooth_value = rms_smooth_value + (rms_smooth_target - rms_smooth_value) * rms_smooth_factor;
);

// Select detection value based on mode
slider6 == 0 ? (
    detected_val = peak_val;  // Peak mode: use raw peak value for fast response
) : (
    detected_val = rms_smooth_value;  // RMS mode: use smooth RMS value
);

// Envelope processing using exponential coefficients
detected_val > env_val ? (
    // Attack phase
    attack_time == 0 ? (
        env_val = detected_val;  // Instant attack
    ) : (
        // Exponential attack
        env_val = env_val * env_attack + detected_val * (1 - env_attack);
    );
) : (
    // Release phase
    release_time == 0 ? (
        env_val = detected_val;  // Instant release
    ) : (
        // Exponential release
        env_val = env_val * env_release + detected_val * (1 - env_release);
    );
);

// Update debug sliders
slider8 = log(max(0.0000001, abs_signal)) * AMP_dB;     // Input signal
slider9 = log(max(0.0000001, peak_val)) * AMP_dB;       // Raw Peak value (fast response)
slider10 = log(max(0.0000001, rms_smooth_value)) * AMP_dB;  // Smooth RMS value
slider11 = log(max(0.0000001, detected_val)) * AMP_dB;  // Detected value
slider24 = log(max(0.0000001, env_val)) * AMP_dB;       // Envelope value

// Convert envelope value to output range (0-100)
env_db = log(max(0.0000001, env_val)) * AMP_dB;
param_out = (env_db + 48) * (100/48); // Scale from -48dB to 0dB to 0-100 range
param_out = max(0, min(100, param_out)); // Clamp to 0-100 range

// Main output
slider1 = param_out;

// Store data in oscilloscope buffer
osc_buffer[osc_buffer_ptr] = slider1;  // Use main output
osc_buffer_ptr = (osc_buffer_ptr + 1) % osc_buffer_size;

// Audition output
slider5 == 1 ? (
    spl0 = filtered_signal;
    spl1 = filtered_signal;
) : (
    spl0 = in0;
    spl1 = in1;
);

@gfx 150 200
// Dark gray background
gfx_r = gfx_g = gfx_b = 0.08;  // Slightly lighter black
gfx_rect(0,0,gfx_w,gfx_h,1);

// Set font size
max_font_size = 18;
min_font_size = 12;
font_size = min(max(gfx_h * 0.06, min_font_size), max_font_size);
gfx_setfont(1, "Arial", font_size, 0);

// Output value display - use brighter white
gfx_set(1,1,1,1);  // Pure white
gfx_x = gfx_w * 0.02;
gfx_y = gfx_h * 0.02;
gfx_printf("Output: %.1f, HPF: %.0f Hz, LPF: %.0f Hz", slider1, hpf_freq, lpf_freq);

// Unified button height
button_h = font_size + 6;

// Improved button style
function draw_button(x, y, w, h, text, is_active) (
    // Button background
    is_active ? (
        gfx_set(0.2,0.7,0.4,1);  // Active state - brighter green
    ) : (
        mouse_cap == 1 && mouse_x >= x && mouse_x <= (x + w) && mouse_y >= y && mouse_y <= (y + h) ? (
            gfx_set(0.25,0.25,0.25,1);  // Hover state - brighter gray
        ) : (
            gfx_set(0.18,0.18,0.18,1);  // Default state - brighter dark gray
        );
    );
    gfx_rect(x, y, w, h, 1);
    
    // Button border
    gfx_set(0.3,0.3,0.3,1);  // Brighter border color
    gfx_rect(x, y, w, h, 0);
    
    // Center text
    text_w = 0; text_h = 0;
    gfx_measurestr(text, text_w, text_h);
    text_x = x + (w - text_w) / 2;
    text_y = y + (h - text_h) / 2;
    
    gfx_set(1,1,1,1);  // Pure white
    gfx_x = floor(text_x);
    gfx_y = floor(text_y);
    gfx_drawstr(text);
);

// Oscilloscope parameters
gfx_osc_x = gfx_w * 0.02;
gfx_osc_y = gfx_h * 0.1;
gfx_osc_w = gfx_w * 0.96;
gfx_osc_h = gfx_h * 0.88;

// Draw grid
gfx_set(0.12,0.12,0.12,1);
i = 0;
while(i <= 5) (
  y = gfx_osc_y + gfx_osc_h * (i/5);
  gfx_line(gfx_osc_x, y, gfx_osc_x + gfx_osc_w, y);
  i += 1;
);
i = 0;
while(i <= 10) (
  x = gfx_osc_x + gfx_osc_w * (i/10);
  gfx_line(x, gfx_osc_y, x, gfx_osc_y + gfx_osc_h);
  i += 1;
);

// Draw waveform with smooth connected lines
gfx_set(0.3,0.9,0.5,1);

// Use optimized drawing algorithm
samples_per_pixel = 2;  // Keep moderate sampling density
total_samples = gfx_osc_w * samples_per_pixel;

// Calculate first point position (skip boundaries)
first_sample_offset = floor(1 * (osc_buffer_size - 1) / (total_samples - 1));
first_buf_idx = (osc_buffer_ptr + first_sample_offset) % osc_buffer_size;
first_val = osc_buffer[first_buf_idx];
first_x = gfx_osc_x + (1 / samples_per_pixel);
first_y = gfx_osc_y + gfx_osc_h * (1.0 - first_val/100);  // Bottom aligned
first_y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, first_y));

// Use smooth line drawing
_osc_plot_prev_x = first_x;
_osc_plot_prev_y = first_y;

i = 2;  // Start from second point
while(i < total_samples-1) (  // End at second to last point
    // Calculate sample point position
    sample_offset = floor(i * (osc_buffer_size - 1) / (total_samples - 1));
    buf_idx = (osc_buffer_ptr + sample_offset) % osc_buffer_size;
    
    // Use simple linear interpolation
    val = osc_buffer[buf_idx];
    
    x = gfx_osc_x + (i / samples_per_pixel);
    y = gfx_osc_y + gfx_osc_h * (1.0 - val/100);  // Bottom aligned
    y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, y));
    
    // Use smooth line drawing
    dx = x - _osc_plot_prev_x;
    dy = y - _osc_plot_prev_y;
    steps = max(abs(dx), abs(dy));
    
    steps > 0 ? (
        x_inc = dx / steps;
        y_inc = dy / steps;
        
        j = 0;
        while(j <= steps) (
            curr_x = _osc_plot_prev_x + j * x_inc;
            curr_y = _osc_plot_prev_y + j * y_inc;
            
            // Use smooth line drawing
            gfx_line(
                curr_x-0.5, curr_y,
                curr_x+0.5, curr_y,
                1
            );
            
            j += 1;
        );
    );
    
    _osc_plot_prev_x = x;
    _osc_plot_prev_y = y;
    
    i += 1;
);

// Add additional smoothing layer
gfx_set(0.3,0.9,0.5,0.3);  // Use semi-transparent color
i = 2;  // Start from second point
while(i < total_samples-2) (  // End at third to last point
    sample_offset = floor(i * (osc_buffer_size - 1) / (total_samples - 1));
    buf_idx = (osc_buffer_ptr + sample_offset) % osc_buffer_size;
    next_buf_idx = (buf_idx + 1) % osc_buffer_size;
    
    val = osc_buffer[buf_idx];
    next_val = osc_buffer[next_buf_idx];
    
    x = gfx_osc_x + (i / samples_per_pixel);
    next_x = gfx_osc_x + ((i + 1) / samples_per_pixel);
    
    y = gfx_osc_y + gfx_osc_h * (1.0 - val/100);  // Bottom aligned
    next_y = gfx_osc_y + gfx_osc_h * (1.0 - next_val/100);  // Bottom aligned
    
    y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, y));
    next_y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, next_y));
    
    // Draw smooth transition
    gfx_line(x, y, next_x, next_y, 1);
    
    i += 1;
);

// Mouse handling
mouse_cap != mouse_last ? (
    mouse_last = mouse_cap;
);
