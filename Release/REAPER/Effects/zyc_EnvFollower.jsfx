desc:zyc_EnvFollower (Envelope Follower)
// @description Zyc EnvFollower - Professional Envelope Follower
// @version 3.3
// @author Yicheng Zhu (Ethan)
// @about
//   # Zyc EnvFollower - Professional Envelope Follower
//
//   A professional grade envelope follower with Peak/RMS detection for dynamic parameter modulation.
//
//   ### Features
//   * **Dual Detection**: Switch between Peak (fast) and RMS (smooth) modes.
//   * **Filter Pre-processing**: Built-in HPF and LPF to target specific frequency ranges.
//   * **Visual Feedback**: Real-time oscilloscope with Cockos-style smooth rendering.
//   * **Output Control**: Generates 0-100 parameter modulation signal.
//   * **RMS Smoothing**: Advanced smoothing control for natural envelope tracking.
//
//   Ideal for sidechain compression, ducking, and dynamic effects!
// @changelog
//   + v3.3: Set RMS Smooth default to 15% for optimal balance
//   + v3.2: Added RMS Smooth control to eliminate step-like changes
//   + v3.1: Fixed Y-coordinate alignment for oscilloscope display
//   + v3.0: Optimized Peak response and smooth drawing

@init
// Basic variable initialization
mouse_last = 0;

// Filter state variables
hpf1_x1 = 0; hpf1_x2 = 0; hpf1_y1 = 0; hpf1_y2 = 0;
hpf2_x1 = 0; hpf2_x2 = 0; hpf2_y1 = 0; hpf2_y2 = 0;
lpf1_x1 = 0; lpf1_x2 = 0; lpf1_y1 = 0; lpf1_y2 = 0;
lpf2_x1 = 0; lpf2_x2 = 0; lpf2_y1 = 0; lpf2_y2 = 0;

// Frequency range (Hz)
min_freq = 20;
max_freq = 20000;

// Volume detection variables - Cockos style
rms_win_len = 0;
rms_win_pos = 0;
rms_sum = 0;
rms_val = 0;
peak_val = 0;

// Smoothing variables - Cockos style
LOUD_METER_SPEED = 0.075;  // 75ms time constant for smoothing
last_t = 0;
th_rms = 0;  // Smoothed RMS display value
th_peak = 0; // Smoothed Peak display value
peak_hold_time = 0.005; // 5ms hold time
peak_decay = exp(-1.0 / (peak_hold_time * srate)); // Calculate decay coefficient based on sample rate
detected_val = 0; // Combined detection value
env_val = 0;      // Initialize envelope value

// RMS Smooth variables - zyc_LFO style
rms_smooth_value = 0;  // Smoothed RMS value for envelope processing
rms_smooth_factor = 0.1;  // Smoothing factor

// Debug variables removed - not used

// Constants
AMP_dB = 8.6562; // 20/log(10)
DB_AMP = 0.11512925464970228420089957273422; // log(10)/20

// Initialize RMS - Cockos style approach
rms_win_len = floor(10 * 0.001 * srate); // Start with 10ms window at project sample rate
rms_win_pos = 0;
rms_sum = 0;

// Oscilloscope buffer initialization
osc_buffer_seconds = 2.0;  // 2秒的显示窗口
osc_buffer_size = floor(srate * osc_buffer_seconds);
osc_buffer_size = max(1, osc_buffer_size);

osc_buffer_ptr = 0;
_osc_init_i = 0;
while (_osc_init_i < osc_buffer_size) (
    osc_buffer[_osc_init_i] = 0.0;
    _osc_init_i += 1;
);

// UI constants
update_interval = 0.016;  // 约60fps的更新率

// Envelope processing variables
env_attack = 1;   // Initialize with instant response
env_release = 1;  // Initialize with instant response

// Delay functionality removed

// Gain variables
gain_linear = 1;

@slider
// Always show main controls
slider_show(1, 1); // Main Output
slider_show(2, 1); // Input Gain
slider_show(3, 1); // HPF
slider_show(4, 1); // LPF
slider_show(5, 1); // Audition
slider_show(6, 1); // Detection Mode
slider_show(7, 1); // RMS Window
slider_show(8, 1); // Input Signal Debug
slider_show(9, 1); // Peak Debug
slider_show(10, 1); // RMS Debug
slider_show(11, 1); // Detected Debug
slider_show(21, 1); // Attack
slider_show(22, 1); // Release
slider_show(24, 1); // Envelope Debug

// Gain - convert dB to linear
gain_linear = exp(slider2 * DB_AMP);

// Convert slider values to actual frequencies (logarithmic scale)
hpf_freq = min_freq * exp(slider3 * log(max_freq/min_freq));
lpf_freq = min_freq * exp(slider4 * log(max_freq/min_freq));

// High-pass filter coefficients
hpf_w0 = 2 * $pi * hpf_freq / srate;
hpf_alpha = sin(hpf_w0) / (2 * 0.707);
hpf_a0 = 1 + hpf_alpha;
hpf_a1 = -2 * cos(hpf_w0);
hpf_a2 = 1 - hpf_alpha;
hpf_b0 = (1 + cos(hpf_w0)) / 2 / hpf_a0;
hpf_b1 = -(1 + cos(hpf_w0)) / hpf_a0;
hpf_b2 = (1 + cos(hpf_w0)) / 2 / hpf_a0;
hpf_a1 /= hpf_a0;
hpf_a2 /= hpf_a0;

// Low-pass filter coefficients
lpf_w0 = 2 * $pi * lpf_freq / srate;
lpf_alpha = sin(lpf_w0) / (2 * 0.707);
lpf_a0 = 1 + lpf_alpha;
lpf_a1 = -2 * cos(lpf_w0);
lpf_a2 = 1 - lpf_alpha;
lpf_b0 = (1 - cos(lpf_w0)) / 2 / lpf_a0;
lpf_b1 = (1 - cos(lpf_w0)) / lpf_a0;
lpf_b2 = (1 - cos(lpf_w0)) / 2 / lpf_a0;
lpf_a1 /= lpf_a0;
lpf_a2 /= lpf_a0;

// Update RMS window size - Cockos style approach
new_win_len = floor(slider7 * 0.001 * srate); // Convert ms to samples at project sample rate
new_win_len = max(1, new_win_len);

// Only reset if window size actually changed
new_win_len != rms_win_len ? (
    rms_win_len = new_win_len;
    rms_win_pos = 0;  // Reset position when window size changes
    rms_sum = 0;      // Reset sum
);

// Debug output moved to @sample to avoid conflicts

// Convert exponential sliders to actual values
attack_time = slider21 == 0 ? 0 : 0.00001 * exp(slider21 * log(500000)); // 0.01ms-5s
release_time = slider22 == 0 ? 0 : 0.00001 * exp(slider22 * log(500000)); // 0.01ms-5s

// RMS Smooth parameter - zyc_LFO style
rms_smooth_param = exp(slider23/100 * 1.5) - 1;  // Convert 0-100% to exponential range

// Calculate envelope coefficients using exponential decay
env_attack = attack_time == 0 ? 1 : exp(-1.0 / (attack_time * srate));
env_release = release_time == 0 ? 0 : exp(-1.0 / (release_time * srate));

// Debug output for envelope times (moved to @sample to avoid conflicts)

// Update peak decay coefficient when sample rate changes
peak_decay = exp(-1.0 / (peak_hold_time * srate));

@sample
// Time-based smoothing - Cockos style
t = time_precise();
speed = last_t ? 1.0-pow(0.5, (t-last_t)/LOUD_METER_SPEED) : 1;
last_t = t;

// Get input signal
in0 = spl0;
in1 = spl1;

// Apply gain to input for filtering
gain_in0 = in0 * gain_linear;
gain_in1 = in1 * gain_linear;

// High-pass filter - 24dB/oct (two second-order cascaded)
// First high-pass filter
hpf1_y0 = hpf_b0 * gain_in0 + hpf_b1 * hpf1_x1 + hpf_b2 * hpf1_x2 - hpf_a1 * hpf1_y1 - hpf_a2 * hpf1_y2;
hpf1_x2 = hpf1_x1;
hpf1_x1 = gain_in0;
hpf1_y2 = hpf1_y1;
hpf1_y1 = hpf1_y0;

// Second high-pass filter
hpf2_y0 = hpf_b0 * hpf1_y0 + hpf_b1 * hpf2_x1 + hpf_b2 * hpf2_x2 - hpf_a1 * hpf2_y1 - hpf_a2 * hpf2_y2;
hpf2_x2 = hpf2_x1;
hpf2_x1 = hpf1_y0;
hpf2_y2 = hpf2_y1;
hpf2_y1 = hpf2_y0;

// Low-pass filter - 24dB/oct (two second-order cascaded)
// First low-pass filter
lpf1_y0 = lpf_b0 * hpf2_y0 + lpf_b1 * lpf1_x1 + lpf_b2 * lpf1_x2 - lpf_a1 * lpf1_y1 - lpf_a2 * lpf1_y2;
lpf1_x2 = lpf1_x1;
lpf1_x1 = hpf2_y0;
lpf1_y2 = lpf1_y1;
lpf1_y1 = lpf1_y0;

// Second low-pass filter
lpf2_y0 = lpf_b0 * lpf1_y0 + lpf_b1 * lpf2_x1 + lpf_b2 * lpf2_x2 - lpf_a1 * lpf2_y1 - lpf_a2 * lpf2_y2;
lpf2_x2 = lpf2_x1;
lpf2_x1 = lpf1_y0;
lpf2_y2 = lpf2_y1;
lpf2_y1 = lpf2_y0;

// Store filtered signal for envelope following
filtered_signal = lpf2_y0;

// Volume detection
abs_signal = abs(filtered_signal);

// Peak detection
abs_signal > peak_val ? (
    peak_val = abs_signal;
) : (
    peak_val *= peak_decay;
);

// Cockos style RMS calculation
rms_sum += abs_signal * abs_signal;  // Accumulate squared samples
rms_win_pos += 1;

// Calculate RMS when window is complete
rms_win_pos >= rms_win_len ? (
    rms_val = sqrt(max(0.0000001, rms_sum / rms_win_len));  // Calculate RMS
    rms_sum = 0;      // Reset accumulator
    rms_win_pos = 0;  // Reset window position
) : (
    rms_val = rms_val;  // Keep previous value during window
);

// Smooth display values - Cockos style
th_rms += (rms_val - th_rms) * speed;
th_peak += (peak_val - th_peak) * speed;

// RMS Smooth processing - zyc_LFO style
rms_smooth_target = rms_val;
rms_smooth_param < 0.001 ? (
    rms_smooth_value = rms_smooth_target;  // No smoothing
) : (
    rms_smooth_factor = 1 - exp(-1 / (srate * rms_smooth_param * 0.1 + 0.000000001));
    rms_smooth_value = rms_smooth_value + (rms_smooth_target - rms_smooth_value) * rms_smooth_factor;
);

// Select detection value based on mode
slider6 == 0 ? (
    detected_val = peak_val;  // Peak mode: use raw peak value for fast response
) : (
    detected_val = rms_smooth_value;  // RMS mode: use smooth RMS value
);

// Envelope processing using exponential coefficients
detected_val > env_val ? (
    // Attack phase
    attack_time == 0 ? (
        env_val = detected_val;  // Instant attack
    ) : (
        // Exponential attack
        env_val = env_val * env_attack + detected_val * (1 - env_attack);
    );
) : (
    // Release phase
    release_time == 0 ? (
        env_val = detected_val;  // Instant release
    ) : (
        // Exponential release
        env_val = env_val * env_release + detected_val * (1 - env_release);
    );
);

// Update debug sliders - Peak shows raw value, RMS shows smoothed value
slider8 = log(max(0.0000001, abs_signal)) * AMP_dB;     // Input signal
slider9 = log(max(0.0000001, peak_val)) * AMP_dB;       // Raw Peak value (fast response)
slider10 = log(max(0.0000001, rms_smooth_value)) * AMP_dB;  // Smooth RMS value
slider11 = log(max(0.0000001, detected_val)) * AMP_dB;  // Detected value
slider24 = log(max(0.0000001, env_val)) * AMP_dB;       // Envelope value

// Convert envelope value to output range (0-100)
env_db = log(max(0.0000001, env_val)) * AMP_dB;
param_out = (env_db + 48) * (100/48); // Scale from -48dB to 0dB to 0-100 range
param_out = max(0, min(100, param_out)); // Clamp to 0-100 range

// Main output
slider1 = param_out;

// 将数据存入示波器缓冲区
osc_buffer[osc_buffer_ptr] = slider1;  // 使用 main output
osc_buffer_ptr = (osc_buffer_ptr + 1) % osc_buffer_size;

// Only main output is used now

// Audition output
slider5 == 1 ? (
    spl0 = filtered_signal;
    spl1 = filtered_signal;
) : (
    spl0 = in0;
    spl1 = in1;
);

@gfx 150 200
// 深灰色背景
gfx_r = gfx_g = gfx_b = 0.08;  // 稍微浅一点的黑色
gfx_rect(0,0,gfx_w,gfx_h,1);

// 设置字体大小
max_font_size = 18;
min_font_size = 12;
font_size = min(max(gfx_h * 0.06, min_font_size), max_font_size);
gfx_setfont(1, "Arial", font_size, 0);

// 输出值显示 - 使用更亮的白色
gfx_set(1,1,1,1);  // 纯白色
gfx_x = gfx_w * 0.02;
gfx_y = gfx_h * 0.02;
gfx_printf("Output: %.1f, HPF: %.0f Hz, LPF: %.0f Hz", slider1, hpf_freq, lpf_freq);

// 统一按钮高度
button_h = font_size + 6;

// UI layout simplified - no extra outputs button needed

// 改进的按钮样式
function draw_button(x, y, w, h, text, is_active) (
    // 按钮背景
    is_active ? (
        gfx_set(0.2,0.7,0.4,1);  // 激活状态 - 更亮的绿色
    ) : (
        mouse_cap == 1 && mouse_x >= x && mouse_x <= (x + w) && mouse_y >= y && mouse_y <= (y + h) ? (
            gfx_set(0.25,0.25,0.25,1);  // 悬停状态 - 更亮的灰色
        ) : (
            gfx_set(0.18,0.18,0.18,1);  // 默认状态 - 更亮的深灰色
        );
    );
    gfx_rect(x, y, w, h, 1);
    
    // 按钮边框
    gfx_set(0.3,0.3,0.3,1);  // 更亮的边框颜色
    gfx_rect(x, y, w, h, 0);
    
    // 文字居中
    text_w = 0; text_h = 0;
    gfx_measurestr(text, text_w, text_h);
    text_x = x + (w - text_w) / 2;
    text_y = y + (h - text_h) / 2;
    
    gfx_set(1,1,1,1);  // 纯白色
    gfx_x = floor(text_x);
    gfx_y = floor(text_y);
    gfx_drawstr(text);
);

// Extra Outputs button removed

// 示波器区参数
gfx_osc_x = gfx_w * 0.02;
gfx_osc_y = gfx_h * 0.1;
gfx_osc_w = gfx_w * 0.96;
gfx_osc_h = gfx_h * 0.88;

// 绘图参数已在波形绘制部分重新定义

// 画网格
gfx_set(0.12,0.12,0.12,1);
i = 0;
while(i <= 5) (
  y = gfx_osc_y + gfx_osc_h * (i/5);
  gfx_line(gfx_osc_x, y, gfx_osc_x + gfx_osc_w, y);
  i += 1;
);
i = 0;
while(i <= 10) (
  x = gfx_osc_x + gfx_osc_w * (i/10);
  gfx_line(x, gfx_osc_y, x, gfx_osc_y + gfx_osc_h);
  i += 1;
);

// 绘制波形 - 参考zyc_LFO的丝滑连接线实现
gfx_set(0.3,0.9,0.5,1);

// 使用优化的绘制算法
samples_per_pixel = 2;  // 保持适中的采样密度
total_samples = gfx_osc_w * samples_per_pixel;

// 计算第一个点的位置（跳过边界）
first_sample_offset = floor(1 * (osc_buffer_size - 1) / (total_samples - 1));
first_buf_idx = (osc_buffer_ptr + first_sample_offset) % osc_buffer_size;
first_val = osc_buffer[first_buf_idx];
first_x = gfx_osc_x + (1 / samples_per_pixel);
first_y = gfx_osc_y + gfx_osc_h * (1.0 - first_val/100);  // 恢复底部对齐
first_y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, first_y));

// 使用平滑的线条绘制
_osc_plot_prev_x = first_x;
_osc_plot_prev_y = first_y;

i = 2;  // 从第二个点开始
while(i < total_samples-1) (  // 到倒数第二个点结束
    // 计算采样点位置
    sample_offset = floor(i * (osc_buffer_size - 1) / (total_samples - 1));
    buf_idx = (osc_buffer_ptr + sample_offset) % osc_buffer_size;
    
    // 使用简单的线性插值
    val = osc_buffer[buf_idx];
    
    x = gfx_osc_x + (i / samples_per_pixel);
    y = gfx_osc_y + gfx_osc_h * (1.0 - val/100);  // 恢复底部对齐
    y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, y));
    
    // 使用平滑的线条绘制
    dx = x - _osc_plot_prev_x;
    dy = y - _osc_plot_prev_y;
    steps = max(abs(dx), abs(dy));
    
    steps > 0 ? (
        x_inc = dx / steps;
        y_inc = dy / steps;
        
        j = 0;
        while(j <= steps) (
            curr_x = _osc_plot_prev_x + j * x_inc;
            curr_y = _osc_plot_prev_y + j * y_inc;
            
            // 使用平滑的线条绘制
            gfx_line(
                curr_x-0.5, curr_y,
                curr_x+0.5, curr_y,
                1
            );
            
            j += 1;
        );
    );
    
    _osc_plot_prev_x = x;
    _osc_plot_prev_y = y;
    
    i += 1;
);

// 添加额外的平滑层 - 参考zyc_LFO的实现
gfx_set(0.3,0.9,0.5,0.3);  // 使用半透明的颜色
i = 2;  // 从第二个点开始
while(i < total_samples-2) (  // 到倒数第三个点结束
    sample_offset = floor(i * (osc_buffer_size - 1) / (total_samples - 1));
    buf_idx = (osc_buffer_ptr + sample_offset) % osc_buffer_size;
    next_buf_idx = (buf_idx + 1) % osc_buffer_size;
    
    val = osc_buffer[buf_idx];
    next_val = osc_buffer[next_buf_idx];
    
    x = gfx_osc_x + (i / samples_per_pixel);
    next_x = gfx_osc_x + ((i + 1) / samples_per_pixel);
    
    y = gfx_osc_y + gfx_osc_h * (1.0 - val/100);  // 恢复底部对齐
    next_y = gfx_osc_y + gfx_osc_h * (1.0 - next_val/100);  // 恢复底部对齐
    
    y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, y));
    next_y = max(gfx_osc_y, min(gfx_osc_y + gfx_osc_h - 1, next_y));
    
    // 绘制平滑过渡
    gfx_line(x, y, next_x, next_y, 1);
    
    i += 1;
);

// Mouse handling simplified - no extra outputs button
mouse_cap != mouse_last ? (
    mouse_last = mouse_cap;
);
