desc:zyc_LFO (FX Parameter Modulator)
//author: EthanZhu @yichengzhu316@outlook.com
//version: v1.2
//changelog:
//v1.2 - Simplified UI
//  - Added extra outputs visibility toggle
//  - Optimized button layout
//v1.1 - Added multiple outputs with range control
//  - Added min/max range control
//  - Added 3 fixed outputs
//  - Added oscilloscope visualization
//  - Implemented 7 waveform types (Sine, Up, Down, Triangle, Square, Random, Binary)
//  - Added Hold and Retrigger controls
//  - Added Jitter with smooth transitions
//  - Added Smooth control with optimized range
//  - Optimized UI layout and controls
//v1 - Initial release
//  - Added oscilloscope visualization
//  - Implemented 7 waveform types (Sine, Up, Down, Triangle, Square, Random, Binary)
//  - Added Hold and Retrigger controls
//  - Added Jitter with smooth transitions
//  - Added Smooth control with optimized range
//  - Optimized UI layout and controls

// Visibility Control
slider50:1<0,1,1{Show Extra,Hide Extra}>Extra Outputs
slider51:1<0,1,1{Show MOOOAAARRR,Hide MOOOAAARRR}>MOOOAAARRR Outputs

slider1:0<-100,100,0.01>Main Output
slider2:0<0,6,1{Sine,Up,Down,Triangle,Square,Random,Bin}>Waveform
slider3:1<0,5,0.01>Rate Fine (Hz)
slider4:0<0,10,0.01>Rate Coarse (Hz)
slider5:100<0,100,0.01>Depth (%)
slider6:0<-100,100,0.01>Offset (%)
slider7:0<0,100,0.01>Jitter (%)
slider8:0<0,100,0.01>Smooth (%)
slider9:0<0,100,0.01>Phase (%)
slider10:0<0,1,1{Off,On}>Hold
slider11:0<0,1,1{Off,Retrigger}>Retrigger

// Extra Output 1 controls
slider12:0<-100,100,0.01>Extra Output 1
slider13:-100<-100,100,0.01>Extra 1 Min
slider14:100<-100,100,0.01>Extra 1 Max

// Extra Output 2 controls
slider15:0<-100,100,0.01>Extra Output 2
slider16:-100<-100,100,0.01>Extra 2 Min
slider17:100<-100,100,0.01>Extra 2 Max

// Extra Output 3 controls
slider18:0<-100,100,0.01>Extra Output 3 
slider19:-100<-100,100,0.01>Extra 3 Min
slider20:100<-100,100,0.01>Extra 3 Max

// MOOOAAARRR Output 1 controls
slider21:0<-100,100,0.01>MOOOAAARRR Output 1
slider22:-100<-100,100,0.01>MOOOAAARRR 1 Min
slider23:100<-100,100,0.01>MOOOAAARRR 1 Max

// MOOOAAARRR Output 2 controls
slider24:0<-100,100,0.01>MOOOAAARRR Output 2
slider25:-100<-100,100,0.01>MOOOAAARRR 2 Min
slider26:100<-100,100,0.01>MOOOAAARRR 2 Max

// MOOOAAARRR Output 3 controls
slider27:0<-100,100,0.01>MOOOAAARRR Output 3
slider28:-100<-100,100,0.01>MOOOAAARRR 3 Min
slider29:100<-100,100,0.01>MOOOAAARRR 3 Max

// MOOOAAARRR Output 4 controls
slider30:0<-100,100,0.01>MOOOAAARRR Output 4
slider31:-100<-100,100,0.01>MOOOAAARRR 4 Min
slider32:100<-100,100,0.01>MOOOAAARRR 4 Max

@init
// 基本变量初始化
two_pi = 2*$pi;
rand_seed = 12345;  // 使用整数作为种子
lfo_phase = 0;
retrigger_last = 0;
bin_value = 1;
random_val = 0;
mouse_last = 0;
hold_val = 0;
smooth_value = 0;

// 初始化slider状态
slider50 = 1;  // Extra Outputs 默认隐藏
slider51 = 1;  // MOOOAAARRR 默认隐藏

// Jitter相关变量
jitter_counter = 0;
jitter_current = 0;
jitter_target = 0;

// 初始化随机数组
i = 0;
while(i < 1000) (
    rand_array[i] = rand() * 2 - 1;
    i += 1;
);
rand_index = 0;

// Oscilloscope buffer initialization
osc_buffer_seconds = 2.0;
osc_buffer_size = floor(srate * osc_buffer_seconds);
osc_buffer_size = max(1, osc_buffer_size);

// 预计算一些常量
min_y = 0;
max_y = 0;
last_update = 0;
update_interval = 0.016;  // 约60fps的更新率

osc_buffer_ptr = 0;
_osc_init_i = 0;
while (_osc_init_i < osc_buffer_size) (
    osc_buffer[_osc_init_i] = 0.0;
    _osc_init_i += 1;
);

// 缓存上一次的绘制结果
prev_draw_buffer = 0;
prev_draw_size = 0;

// 平滑过渡变量
smooth_factor = 0.1;
last_draw_time = 0;

// UI state variables
ui_spacing = 5;

function rand() (
    rand_seed = (rand_seed * 1103515245 + 12345) & 0x7fffffff;
    rand_seed / 0x7fffffff;
);

@slider
// Always show main controls and toggle
slider_show(1, 1); // Main Output
slider_show(2, 1); // Waveform
slider_show(4, 1); // Rate Fine (Hz)
slider_show(8, 1); // Rate Coarse (Hz)
slider_show(16, 1); // Depth (%)
slider_show(32, 1); // Offset (%)
slider_show(64, 1); // Jitter (%)
slider_show(128, 1); // Smooth (%)
slider_show(256, 1); // Phase (%)
slider_show(512, 0); // Hold
slider_show(1024, 0); // Retrigger

// 隐藏toggle sliders
slider_show(1125899906842624, 0);  // Extra Outputs toggle (2^50)
slider_show(2251799813685248, 0);  // MOOOAAARRR Outputs toggle (2^51)

// 控制extra output相关sliders的显示/隐藏
slider_show(2095104, slider50 == 0 ? 1 : 0);  // Extra Outputs (sliders 12-20)

// 控制MOOOAAARRR output相关sliders的显示/隐藏
slider_show(4293918720, slider50 == 0 && slider51 == 0 ? 1 : 0);  // MOOOAAARRR Outputs (sliders 21-32)

waveform = slider2;
rate = slider3 + slider4;
depth = slider5/100;
offset = slider6/100;
jitter_amt = slider7/100;
smooth = exp(slider8/100 * 1.5) - 1;
phase = slider9/100;

@sample
// 更新状态
hold = slider10;
retrigger = slider11;

// Retrigger处理
retrigger_last != retrigger ? (
    retrigger_last = retrigger;
    retrigger == 1 ? lfo_phase = 0;
);

// 相位计算
srate > 0 ? phase_inc = rate / srate : phase_inc = 0;

lfo_phase += phase_inc;
lfo_phase -= floor(lfo_phase);

lfo_phase_mod = lfo_phase + phase;
lfo_phase_mod -= floor(lfo_phase_mod);

// 波形生成
lfo_shape_val =
    waveform == 0 ? -cos(lfo_phase_mod * two_pi) :
    waveform == 1 ? 2 * lfo_phase_mod - 1 :
    waveform == 2 ? 1 - 2 * lfo_phase_mod :
    waveform == 3 ? (lfo_phase_mod < 0.5 ? 4 * lfo_phase_mod - 1 : 3 - 4 * lfo_phase_mod) :
    waveform == 4 ? (floor(lfo_phase_mod * 2) == 0 ? 1 : -1) :
    waveform == 5 ? (
        lfo_phase_mod < phase_inc ? (
            random_val = rand() * 2 - 1;  // 直接使用rand()生成新的随机值
        );
        random_val;
    ) :
    waveform == 6 ? (
        lfo_phase_mod < phase_inc ? (
            bin_value = rand() >= 0.5 ? 1 : -1;  // 生成新的目标值
            bin_smooth_target = bin_value;  // 设置平滑过渡的目标值
        );
        // 平滑过渡到目标值
        bin_smooth_factor = 0.1;  // 平滑因子
        bin_smooth_current = bin_smooth_current + (bin_smooth_target - bin_smooth_current) * bin_smooth_factor;
        bin_smooth_current;
    ) :
    0;

// Depth和Offset处理
raw_value = offset + depth * lfo_shape_val;
raw_value = max(-1, min(1, raw_value));

// Jitter处理
jitter_counter += 1;
jitter_counter >= 20 ? (  // 改为20个采样点
    jitter_counter = 0;
    jitter_target = rand() * 2 - 1;  // 生成新的目标值
);
// 平滑过渡到目标值
jitter_current = jitter_current + (jitter_target - jitter_current) * 0.1;  // 0.1是过渡速度
_jitter_rand_val = jitter_current * jitter_amt;
raw_value = raw_value + _jitter_rand_val;
raw_value = max(-1, min(1, raw_value));

// Smooth处理
smooth_val_target = raw_value;
smooth < 0.001 ? (
    smooth_value = smooth_val_target;
) : (
    smooth_factor = 1 - exp(-1 / (srate * smooth * 0.1 + 0.000000001));
    smooth_value = smooth_value + (smooth_val_target - smooth_value) * smooth_factor;
);

// 输出处理
param_out = smooth_value * 100;

// 将数据存入示波器缓冲区
(osc_buffer_size > 0 && srate > 0) ? (
    osc_buffer[osc_buffer_ptr] = slider1;
    osc_buffer_ptr = (osc_buffer_ptr + 1) % osc_buffer_size;
);

// Hold处理
hold ? slider1 = hold_val : (slider1 = param_out; hold_val = param_out);

// 计算额外输出
function scale_output(input, min_val, max_val) (
    range = max_val - min_val;
    range != 0 ? (
        scaled = min_val + (input + 100) * range / 200;
        scaled;
    ) : (
        min_val;
    );
);

// 更新额外输出
slider50 == 0 ? (
    slider12 = scale_output(param_out, slider13, slider14);
    slider15 = scale_output(param_out, slider16, slider17);
    slider18 = scale_output(param_out, slider19, slider20);
    
    // 更新MOOOAAARRR输出
    slider51 == 0 ? (
        slider21 = scale_output(param_out, slider22, slider23);
        slider24 = scale_output(param_out, slider25, slider26);
        slider27 = scale_output(param_out, slider28, slider29);
        slider30 = scale_output(param_out, slider31, slider32);
    );
);

@gfx 150 240  // 设置高度为240像素

// 深灰色背景
gfx_r = gfx_g = gfx_b = 0.08;  // 稍微浅一点的黑色
gfx_rect(0,0,gfx_w,gfx_h,1);

// 设置字体大小
max_font_size = 18;
min_font_size = 12;
font_size = min(max(gfx_h * 0.06, min_font_size), max_font_size);
gfx_setfont(1, "Arial", font_size, 0);

// 输出值显示 - 使用更亮的白色
gfx_set(1,1,1,1);  // 纯白色
gfx_x = gfx_w * 0.02;
gfx_y = gfx_h * 0.02;
gfx_printf("LFO Out: %.2f", slider1);

// 统一按钮高度
button_h = font_size + 8;  // 增加按钮高度，从+6改为+8

// 计算按钮宽度
_extra_text_w = 0; _extra_text_h = 0;
gfx_measurestr("Extra Outputs", _extra_text_w, _extra_text_h);
_extra_w = _extra_text_w + font_size * 0.8;

_moooaarrr_text_w = 0; _moooaarrr_text_h = 0;
gfx_measurestr("MOOOAAARRR!", _moooaarrr_text_w, _moooaarrr_text_h);
_moooaarrr_w = _moooaarrr_text_w + font_size * 0.8;

_retrigger_text_w = 0; _retrigger_text_h = 0;
gfx_measurestr("Retrigger", _retrigger_text_w, _retrigger_text_h);
_retrigger_w = _retrigger_text_w + font_size * 0.8;

_hold_text_w = 0; _hold_text_h = 0;
gfx_measurestr("Hold", _hold_text_w, _hold_text_h);
_hold_w = _hold_text_w + font_size * 0.8;

// 统一间距
btn_spacing = font_size * 0.6;

// 计算按钮位置
_hold_x = gfx_w - gfx_w * 0.04 - _hold_w;
_hold_y = gfx_h * 0.02;
_retrigger_x = _hold_x - btn_spacing - _retrigger_w;
_retrigger_y = _hold_y;
_moooaarrr_x = _retrigger_x - btn_spacing - _moooaarrr_w;
_moooaarrr_y = _hold_y;
_extra_x = _moooaarrr_x - btn_spacing - _extra_w;
_extra_y = _hold_y;

// 改进的按钮样式
function draw_button(x, y, w, h, text, is_active) (
    // 按钮背景
    is_active ? (
        gfx_set(0.2,0.7,0.4,1);  // 激活状态 - 更亮的绿色
    ) : (
        mouse_cap == 1 && mouse_x >= x && mouse_x <= (x + w) && mouse_y >= y && mouse_y <= (y + h) ? (
            gfx_set(0.25,0.25,0.25,1);  // 悬停状态 - 更亮的灰色
        ) : (
            gfx_set(0.18,0.18,0.18,1);  // 默认状态 - 更亮的深灰色
        );
    );
    gfx_rect(x, y, w, h, 1);
    
    // 按钮边框
    gfx_set(0.3,0.3,0.3,1);  // 更亮的边框颜色
    gfx_rect(x, y, w, h, 0);
    
    // 文字居中
    text_w = 0; text_h = 0;
    gfx_measurestr(text, text_w, text_h);
    text_x = x + (w - text_w) / 2;
    text_y = y + (h - text_h) / 2;
    
    gfx_set(1,1,1,1);  // 纯白色
    gfx_x = floor(text_x);
    gfx_y = floor(text_y);
    gfx_drawstr(text);
);

draw_button(_extra_x, _extra_y, _extra_w, button_h, "Extra Outputs", slider50 == 0);
slider50 == 0 ? draw_button(_moooaarrr_x, _moooaarrr_y, _moooaarrr_w, button_h, "MOOOAAARRR!", slider51 == 0);
draw_button(_retrigger_x, _retrigger_y, _retrigger_w, button_h, "Retrigger", slider11 == 1);
draw_button(_hold_x, _hold_y, _hold_w, button_h, "Hold", slider10 == 1);

// --- Oscilloscope Drawing ---
gfx_osc_x_start = gfx_w * 0.02;
gfx_osc_y_start = _hold_y + button_h + font_size * 0.5;
gfx_osc_w = gfx_w * 0.96;
gfx_osc_h = gfx_h - gfx_osc_y_start - gfx_h * 0.03;

osc_buffer_is_valid = osc_buffer_size > 0 && gfx_osc_w > 1 && srate > 0;

osc_buffer_is_valid ? (
    // 绘制网格
    gfx_set(0.12,0.12,0.12,1);
    
    // 水平网格线
    grid_lines = 5;
    grid_spacing = gfx_osc_h / grid_lines;
    i = 0;
    while(i <= grid_lines) (
        y = gfx_osc_y_start + i * grid_spacing;
        gfx_line(gfx_osc_x_start, y, gfx_osc_x_start + gfx_osc_w, y);
        i += 1;
    );
    
    // 垂直网格线
    grid_lines = 10;
    grid_spacing = gfx_osc_w / grid_lines;
    i = 0;
    while(i <= grid_lines) (
        x = gfx_osc_x_start + i * grid_spacing;
        gfx_line(x, gfx_osc_y_start, x, gfx_osc_y_start + gfx_osc_h);
        i += 1;
    );

    // 绘制中心线
    gfx_set(0.15,0.15,0.15,1);
    gfx_line(gfx_osc_x_start, gfx_osc_y_start + gfx_osc_h/2, 
             gfx_osc_x_start + gfx_osc_w, gfx_osc_y_start + gfx_osc_h/2);

    // 绘制波形
    gfx_set(0.3,0.9,0.5,1);
    
    // 使用优化的绘制算法
    samples_per_pixel = 2;  // 保持适中的采样密度
    total_samples = gfx_osc_w * samples_per_pixel;
    
    // 计算第一个点的位置（跳过边界）
    first_sample_offset = floor(1 * (osc_buffer_size - 1) / (total_samples - 1));
    first_buf_idx = (osc_buffer_ptr + first_sample_offset) % osc_buffer_size;
    first_val = osc_buffer[first_buf_idx];
    first_x = gfx_osc_x_start + (1 / samples_per_pixel);
    first_y = gfx_osc_y_start + gfx_osc_h/2 - (first_val / 100 * (gfx_osc_h/2));
    first_y = max(gfx_osc_y_start, min(gfx_osc_y_start + gfx_osc_h - 1, first_y));
    
    // 使用平滑的线条绘制
    _osc_plot_prev_x = first_x;
    _osc_plot_prev_y = first_y;
    
    i = 2;  // 从第二个点开始
    while(i < total_samples-1) (  // 到倒数第二个点结束
        // 计算采样点位置
        sample_offset = floor(i * (osc_buffer_size - 1) / (total_samples - 1));
        buf_idx = (osc_buffer_ptr + sample_offset) % osc_buffer_size;
        
        // 使用简单的线性插值
        val = osc_buffer[buf_idx];
        
        x = gfx_osc_x_start + (i / samples_per_pixel);
        y = gfx_osc_y_start + gfx_osc_h/2 - (val / 100 * (gfx_osc_h/2));
        y = max(gfx_osc_y_start, min(gfx_osc_y_start + gfx_osc_h - 1, y));
        
        // 使用平滑的线条绘制
        dx = x - _osc_plot_prev_x;
        dy = y - _osc_plot_prev_y;
        steps = max(abs(dx), abs(dy));
        
        steps > 0 ? (
            x_inc = dx / steps;
            y_inc = dy / steps;
            
            j = 0;
            while(j <= steps) (
                curr_x = _osc_plot_prev_x + j * x_inc;
                curr_y = _osc_plot_prev_y + j * y_inc;
                
                // 使用平滑的线条绘制
                gfx_line(
                    curr_x-0.5, curr_y,
                    curr_x+0.5, curr_y,
                    1
                );
                
                j += 1;
            );
        );
        
        _osc_plot_prev_x = x;
        _osc_plot_prev_y = y;
        
        i += 1;
    );
    
    // 添加额外的平滑层
    gfx_set(0.3,0.9,0.5,0.3);  // 使用半透明的颜色
    i = 2;  // 从第二个点开始
    while(i < total_samples-2) (  // 到倒数第三个点结束
        sample_offset = floor(i * (osc_buffer_size - 1) / (total_samples - 1));
        buf_idx = (osc_buffer_ptr + sample_offset) % osc_buffer_size;
        next_buf_idx = (buf_idx + 1) % osc_buffer_size;
        
        val = osc_buffer[buf_idx];
        next_val = osc_buffer[next_buf_idx];
        
        x = gfx_osc_x_start + (i / samples_per_pixel);
        next_x = gfx_osc_x_start + ((i + 1) / samples_per_pixel);
        
        y = gfx_osc_y_start + gfx_osc_h/2 - (val / 100 * (gfx_osc_h/2));
        next_y = gfx_osc_y_start + gfx_osc_h/2 - (next_val / 100 * (gfx_osc_h/2));
        
        y = max(gfx_osc_y_start, min(gfx_osc_y_start + gfx_osc_h - 1, y));
        next_y = max(gfx_osc_y_start, min(gfx_osc_y_start + gfx_osc_h - 1, next_y));
        
        // 绘制平滑过渡
        gfx_line(x, y, next_x, next_y, 1);
        
        i += 1;
    );
);

// 鼠标处理
mouse_cap != mouse_last ? (
    mouse_cap == 1 ? (
        // Extra Outputs按钮
        mouse_x >= _extra_x && mouse_x <= (_extra_x + _extra_w) && mouse_y >= _extra_y && mouse_y <= (_extra_y + button_h) ? (
            slider50 = !slider50;
            slider_automate(slider50);
            slider_show(2095104, slider50 == 0 ? 1 : 0);
            slider50 == 1 ? (
                slider51 = 1;  // 如果隐藏Extra，也隐藏MOOOAAARRR
                slider_show(4293918720, 0);  // 隐藏MOOOAAARRR的sliders
            );
        );
        // MOOOAAARRR按钮 - 只在Extra Outputs显示时才处理点击
        slider50 == 0 && mouse_x >= _moooaarrr_x && mouse_x <= (_moooaarrr_x + _moooaarrr_w) && mouse_y >= _moooaarrr_y && mouse_y <= (_moooaarrr_y + button_h) ? (
            slider51 = !slider51;
            slider_automate(slider51);
            slider_show(4293918720, slider50 == 0 && slider51 == 0 ? 1 : 0);
        );
        // Hold按钮
        mouse_x >= _hold_x && mouse_x <= (_hold_x + _hold_w) && mouse_y >= _hold_y && mouse_y <= (_hold_y + button_h) ? (
            slider10 = !slider10;
            slider_automate(slider10);
        );
        // Retrigger按钮
        mouse_x >= _retrigger_x && mouse_x <= (_retrigger_x + _retrigger_w) && mouse_y >= _retrigger_y && mouse_y <= (_retrigger_y + button_h) ? (
            slider11 = 1;
            slider_automate(slider11);
        );
    ) : (
        slider11 = 0;
        slider_automate(slider11);
    );
    mouse_last = mouse_cap;
);

// 在右下角绘制像素洋葱
function draw_pixel_onion(x, y) (
    // 设置洋葱颜色 - 淡紫色
    gfx_set(0.8, 0.6, 0.9, 1);
    
    // 洋葱主体 - 横向椭圆
    gfx_rect(x, y+2, 12, 4, 1);   // 最外层
    gfx_rect(x+1, y+1, 10, 6, 1); // 中间层
    gfx_rect(x+2, y, 8, 8, 1);    // 内层
    
    // 洋葱顶部
    gfx_rect(x+4, y-2, 4, 2, 1);  // 顶部
    gfx_rect(x+3, y-1, 6, 1, 1);  // 连接
    
    // 洋葱竖条纹 - 深紫色，带弧度
    gfx_set(0.6, 0.4, 0.7, 1);
    // 左条纹
    gfx_line(x+3, y, x+2, y+2, 1);
    gfx_line(x+2, y+2, x+3, y+4, 1);
    gfx_line(x+3, y+4, x+2, y+6, 1);
    gfx_line(x+2, y+6, x+3, y+8, 1);
    
    // 中左条纹
    gfx_line(x+5, y, x+4, y+2, 1);
    gfx_line(x+4, y+2, x+5, y+4, 1);
    gfx_line(x+5, y+4, x+4, y+6, 1);
    gfx_line(x+4, y+6, x+5, y+8, 1);
    
    // 中右条纹
    gfx_line(x+7, y, x+6, y+2, 1);
    gfx_line(x+6, y+2, x+7, y+4, 1);
    gfx_line(x+7, y+4, x+6, y+6, 1);
    gfx_line(x+6, y+6, x+7, y+8, 1);
    
    // 右条纹
    gfx_line(x+9, y, x+8, y+2, 1);
    gfx_line(x+8, y+2, x+9, y+4, 1);
    gfx_line(x+9, y+4, x+8, y+6, 1);
    gfx_line(x+8, y+6, x+9, y+8, 1);
    
    // 添加一些高光
    gfx_set(0.9, 0.7, 1, 1);  // 更亮的紫色
    gfx_rect(x+4, y+2, 4, 4, 1);  // 中心高光
);

// 在右下角绘制洋葱
draw_pixel_onion(gfx_w - 16, gfx_h - 10);
